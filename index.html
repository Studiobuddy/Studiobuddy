<!DOCTYPE html>
<html>
<head>
    <title>StudioBuddy - Free Fashion Design Studio</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #8B008B 0%, #FF1493 100%);
        }

        /* ===== LANDING PAGE STYLES ===== */
        #landing-page {
            min-height: 100vh;
            color: white;
            text-align: center;
            padding: 40px 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .logo {
            font-size: 4em;
            margin-bottom: 20px;
        }
        
        .main-title {
            font-size: 3.5em;
            font-weight: bold;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #FFFFFF, #FFB6C1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .student-tagline {
            font-size: 1.2em;
            color: #fff;
            background: rgba(219, 112, 147, 0.8);
            padding: 8px 20px;
            border-radius: 20px;
            margin-bottom: 10px;
        }
        
        .tagline {
            font-size: 1.5em;
            margin-bottom: 30px;
            opacity: 0.9;
        }
        
        .launch-btn {
            background: white;
            color: #8B008B;
            border: none;
            padding: 20px 50px;
            font-size: 1.5em;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            margin: 30px 0;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        
        .launch-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px rgba(0,0,0,0.3);
        }
        
        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 40px 0;
            max-width: 1000px;
        }
        
        .feature-card {
            background: rgba(255,255,255,0.2);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.3);
        }

        /* ===== EDITOR STYLES ===== */
        #editor-page {
            display: none;
            min-height: 100vh;
            background: linear-gradient(135deg, #f5f5f5 0%, #ffe6f2 100%);
        }
        
        .editor-header {
            background: linear-gradient(135deg, #8B008B 0%, #FF1493 100%);
            padding: 15px 30px;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .editor-title {
            font-size: 1.8em;
            font-weight: bold;
        }
        
        .welcome-message {
            font-size: 1.2em;
            color: rgba(255,255,255,0.9);
            font-style: italic;
        }
        
        .back-btn {
            background: white;
            color: #8B008B;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .editor-container {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            gap: 20px;
        }
        
        .tool-panel {
            width: 320px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(139, 0, 139, 0.1);
            overflow-y: auto;
            max-height: calc(100vh - 100px);
            border: 1px solid rgba(255, 20, 147, 0.2);
        }
        
        .canvas-area {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            text-align: center;
            min-height: 650px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            border: 2px solid rgba(255, 20, 147, 0.3);
        }
        
        .tool-section {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #ffe6f2;
        }
        
        .tool-section h3 {
            color: #8B008B;
            margin-bottom: 15px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tool-btn {
            background: white;
            color: #333;
            border: 2px solid #FF1493;
            padding: 10px;
            margin: 3px 0;
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
            font-size: 14px;
            text-align: left;
            transition: all 0.2s;
        }
        
        .tool-btn:hover {
            background: #FF1493;
            color: white;
        }
        
        .active-tool {
            background: #FF1493 !important;
            color: white !important;
            border-color: #FF1493 !important;
        }
        
        /* CANVAS */
        #main-canvas {
            border: 3px solid #8B008B !important;
            background: #fff !important;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(139, 0, 139, 0.1);
            cursor: crosshair;
        }
        
        .status-bar {
            background: #ffe6f2;
            padding: 12px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #FF1493;
            font-size: 14px;
            width: 100%;
        }
        
        .brush-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        
        .brush-btn {
            padding: 8px;
            border: 1px solid #FFB6C1;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            text-align: center;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .brush-btn:hover {
            background: #FFB6C1;
            color: white;
        }
        
        .shape-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        
        .shape-btn {
            padding: 8px;
            border: 1px solid #FFB6C1;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            text-align: center;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .shape-btn:hover {
            background: #FFB6C1;
            color: white;
        }
        
        /* Pages Panel */
        .pages-panel {
            position: absolute;
            left: 20px;
            top: 20px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(139, 0, 139, 0.1);
            z-index: 100;
            max-height: 500px;
            overflow-y: auto;
            width: 150px;
            border: 1px solid #FFB6C1;
        }
        
        .page-thumbnail {
            margin: 5px 0;
            padding: 8px;
            background: #ffe6f2;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .page-thumbnail.active {
            border-color: #FF1493;
            background: #ffcce0;
        }
        
        .page-thumbnail:hover {
            background: #ffcce0;
        }
        
        .add-page-btn {
            background: #FF1493;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .add-page-btn:hover {
            background: #8B008B;
        }
        
        /* Download Modal */
        .download-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .download-container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            width: 500px;
            max-width: 90%;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            border: 3px solid #FF1493;
        }
        
        .download-header {
            color: #8B008B;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ffe6f2;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .close-download-btn {
            background: #FF1493;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .download-options {
            margin: 20px 0;
        }
        
        .page-option {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: #ffe6f2;
            border-radius: 8px;
            transition: all 0.2s;
        }
        
        .page-option:hover {
            background: #ffcce0;
        }
        
        .page-option input[type="checkbox"] {
            margin-right: 15px;
            width: 18px;
            height: 18px;
            accent-color: #FF1493;
        }
        
        .download-action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 25px;
        }
        
        .download-action-btn {
            padding: 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.2s;
        }
        
        .download-all-btn {
            background: linear-gradient(135deg, #FF1493, #8B008B);
            color: white;
        }
        
        .download-selected-btn {
            background: linear-gradient(135deg, #8B008B, #4B0082);
            color: white;
        }
        
        .download-all-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 20, 147, 0.4);
        }
        
        .download-selected-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(139, 0, 139, 0.4);
        }
        
        /* Templates Modal */
        .templates-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .templates-container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            width: 800px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            border: 3px solid #FF1493;
        }
        
        .templates-header {
            color: #8B008B;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ffe6f2;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .close-templates-btn {
            background: #FF1493;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .templates-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .template-card {
            background: #ffe6f2;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid #FFB6C1;
        }
        
        .template-card:hover {
            transform: translateY(-5px);
            background: #ffcce0;
            border-color: #FF1493;
        }
        
        .template-icon {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .template-name {
            font-weight: bold;
            color: #8B008B;
            margin-bottom: 5px;
        }
        
        .template-desc {
            font-size: 12px;
            color: #666;
        }
        
        /* PDF Viewer Modal */
        .pdf-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .pdf-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            height: 90%;
            display: flex;
            flex-direction: column;
        }
        
        .pdf-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #FF1493;
        }
        
        .pdf-canvas-container {
            flex: 1;
            overflow: auto;
            border: 1px solid #ddd;
            padding: 10px;
            background: #f9f9f9;
        }
        
        .pdf-nav {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
            padding: 10px;
            background: #ffe6f2;
            border-radius: 5px;
        }
        
        .pdf-nav button {
            background: #FF1493;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        @media (max-width: 768px) {
            .main-title { font-size: 2.5em; }
            .editor-container { flex-direction: column; }
            .tool-panel { width: 100%; max-height: none; }
            #main-canvas { width: 100% !important; }
            .pages-panel { position: static; width: 100%; margin-bottom: 20px; }
            .download-action-buttons { grid-template-columns: 1fr; }
            .templates-grid { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <!-- ===== LANDING PAGE ===== -->
    <div id="landing-page">
        <div class="logo">üé®</div>
        <h1 class="main-title">StudioBuddy</h1>
        <div class="student-tagline">made for students by students</div>
        <p class="tagline">Free Fashion Design Studio + Notes & PDF Annotation</p>
        
        <button class="launch-btn" onclick="launchEditor()">
            üöÄ Launch Free Studio
        </button>
        
        <div class="features">
            <div class="feature-card">
                <h3>üé® Professional Design</h3>
                <p>Fashion tools, cutouts, sketch filters, and measurements</p>
            </div>
            <div class="feature-card">
                <h3>üìù Smart Notes</h3>
                <p>GoodNotes-style clean writing with smoothing</p>
            </div>
            <div class="feature-card">
                <h3>üìö Multi-Page & PDF</h3>
                <p>Multiple canvases, PDF uploads, and annotation</p>
            </div>
        </div>
    </div>
    
    <!-- ===== EDITOR PAGE ===== -->
    <div id="editor-page">
        <div class="editor-header">
            <div>
                <div class="editor-title">üé® StudioBuddy</div>
                <div class="welcome-message">Welcome to StudioBuddy!</div>
            </div>
            <button class="back-btn" onclick="backToLanding()">‚Üê Back to Home</button>
        </div>
        
        <div class="editor-container">
            <!-- Left Tool Panel -->
            <div class="tool-panel">
                <div class="tool-section">
                    <h3>üìÅ FILE</h3>
                    <button class="tool-btn" onclick="uploadImage()">üì§ Upload Image</button>
                    <button class="tool-btn" onclick="uploadPDF()">üìÑ Upload & View PDF</button>
                    <button class="tool-btn" onclick="convertToSketch()">‚úèÔ∏è Convert to Sketch</button>
                    <button class="tool-btn" onclick="saveTemplate()">üíæ Save Template</button>
                    <button class="tool-btn" onclick="downloadDesign()">‚¨áÔ∏è Download PNG</button>
                    <button class="tool-btn" onclick="downloadAllPages()">üìö Download Pages...</button>
                    <button class="tool-btn" onclick="loadTemplates()">üé® Load Templates</button>
                    <button class="tool-btn" onclick="clearCanvas()">üóëÔ∏è Clear Canvas</button>
                </div>
                
                <div class="tool-section">
                    <h3>üìö PAGES</h3>
                    <button class="tool-btn" onclick="addNewPage()">‚ûï Add New Page</button>
                    <button class="tool-btn" onclick="duplicateCurrentPage()">üìÑ Duplicate Page</button>
                    <button class="tool-btn" onclick="deleteCurrentPage()">üóëÔ∏è Delete Page</button>
                    <div class="clean-writing-toggle">
                        <label class="toggle-switch">
                            <input type="checkbox" id="clean-writing-toggle" checked onchange="toggleCleanWriting()">
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Clean Writing</span>
                    </div>
                    <button class="tool-btn" onclick="smoothAllDrawings()">‚ú® Smooth All Drawings</button>
                </div>
                
                <div class="tool-section">
                    <h3>üõ†Ô∏è TOOLS</h3>
                    <button class="tool-btn" id="select-btn" onclick="setTool('select')">‚úã Select & Move</button>
                    <button class="tool-btn" id="draw-btn" onclick="setTool('draw')">‚úèÔ∏è Draw Freehand</button>
                    <button class="tool-btn" id="cutout-btn" onclick="startCutoutMode()">‚úÇÔ∏è Image Cutout</button>
                    <button class="tool-btn" onclick="addText()">üî§ Add Text</button>
                    <button class="tool-btn" id="ruler-btn" onclick="toggleRuler()">üìè Measurement Ruler</button>
                    <button class="tool-btn" id="symmetry-btn" onclick="toggleSymmetry()">üîÑ Symmetry</button>
                    
                    <div class="shape-buttons">
                        <button class="shape-btn" onclick="addShape('rectangle')">‚¨ú Rectangle</button>
                        <button class="shape-btn" onclick="addShape('circle')">‚≠ï Circle</button>
                        <button class="shape-btn" onclick="addShape('triangle')">üî∫ Triangle</button>
                        <button class="shape-btn" onclick="addShape('line')">üìè Line</button>
                        <button class="shape-btn" onclick="addShape('arrow')">‚û°Ô∏è Arrow</button>
                        <button class="shape-btn" onclick="addShape('star')">‚≠ê Star</button>
                        <button class="shape-btn" onclick="addShape('heart')">‚ù§Ô∏è Heart</button>
                        <button class="shape-btn" onclick="addShape('hexagon')">‚¨¢ Hexagon</button>
                        <button class="shape-btn" onclick="addShape('oval')">ü•ö Oval</button>
                    </div>
                </div>
                
                <div class="tool-section">
                    <h3>üé® BRUSHES & COLORS</h3>
                    <div class="brush-buttons">
                        <button class="brush-btn" onclick="setBrush('pencil')">‚úèÔ∏è Pencil</button>
                        <button class="brush-btn" onclick="setBrush('handwriting')">‚úçÔ∏è Handwriting</button>
                        <button class="brush-btn" onclick="setBrush('marker')">üñçÔ∏è Marker</button>
                        <button class="brush-btn" onclick="setBrush('watercolor')">üé® Watercolor</button>
                        <button class="brush-btn" onclick="setBrush('charcoal')">ü™® Charcoal</button>
                        <button class="brush-btn" onclick="setBrush('spray')">üí® Spray</button>
                        <button class="brush-btn" onclick="setBrush('chalk')">ü™® Chalk</button>
                        <button class="brush-btn" onclick="setBrush('highlighter')">üü° Highlighter</button>
                        <button class="brush-btn" onclick="setBrush('calligraphy')">‚úíÔ∏è Calligraphy</button>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <input type="color" id="brush-color" onchange="changeBrushColor(this.value)" 
                                   style="width: 40px; height: 40px; border: none; border-radius: 4px; cursor: pointer;" value="#000000">
                            <span>Drawing Color</span>
                        </div>
                        
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="color" id="fill-color" onchange="changeFillColor(this.value)" 
                                   style="width: 40px; height: 40px; border: none; border-radius: 4px; cursor: pointer;" value="#FF1493">
                            <span>Shape Fill</span>
                        </div>
                        
                        <div style="margin-top: 10px;">
                            <label>Brush Size: <span id="brush-size-value">3</span>px</label>
                            <input type="range" id="brush-size" min="1" max="50" value="3" 
                                   onchange="changeBrushSize(this.value)" style="width: 100%;">
                        </div>
                        <div style="margin-top: 10px;">
                            <label>Smoothing: <span id="smoothing-value">0.7</span></label>
                            <input type="range" id="smoothing-slider" min="0" max="1" step="0.1" value="0.7" 
                                   onchange="changeSmoothing(this.value)" style="width: 100%;">
                        </div>
                    </div>
                </div>
                
                <div class="tool-section">
                    <h3>üëó FASHION TOOLS</h3>
                    <button class="tool-btn" onclick="addMannequin()">üßç Full Mannequin</button>
                    <button class="tool-btn" onclick="addFrenchCurve()">üåÄ French Curve</button>
                    <button class="tool-btn" onclick="addGrid()">üî≤ Grid Overlay (for Notes)</button>
                </div>
                
                <div class="status-bar" id="status">
                    <strong>Status:</strong> Ready to create!
                </div>
            </div>
            
            <!-- Right Canvas Area -->
            <div class="canvas-area">
                <!-- Pages Panel -->
                <div class="pages-panel" id="pages-panel">
                    <div style="font-weight: bold; margin-bottom: 10px; color: #8B008B;">Pages</div>
                    <div id="pages-list"></div>
                    <button class="add-page-btn" onclick="addNewPage()">+ Add Page</button>
                </div>
                
                <canvas id="main-canvas" width="800" height="600"></canvas>
                
                <div style="margin-top: 20px; color: #666; font-size: 0.9em;">
                    <p>üí° <strong>Tips:</strong> Use Grid for note-taking ‚Ä¢ Click ruler points for measurements</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Download Modal -->
    <div class="download-modal" id="download-modal">
        <div class="download-container">
            <div class="download-header">
                <h2>üìö Download Pages</h2>
                <button class="close-download-btn" onclick="closeDownloadModal()">‚úï</button>
            </div>
            
            <div class="download-options" id="download-options">
                <!-- Page options will be generated here -->
            </div>
            
            <div class="download-action-buttons">
                <button class="download-action-btn download-all-btn" onclick="downloadAllPagesAsZip()">
                    üì• Download All Pages
                </button>
                <button class="download-action-btn download-selected-btn" onclick="downloadSelectedPages()">
                    ‚úÖ Download Selected Pages
                </button>
            </div>
        </div>
    </div>

    <!-- Templates Modal -->
    <div class="templates-modal" id="templates-modal">
        <div class="templates-container">
            <div class="templates-header">
                <h2>üé® Choose a Template</h2>
                <button class="close-templates-btn" onclick="closeTemplatesModal()">‚úï</button>
            </div>
            
            <div class="templates-grid" id="templates-grid">
                <!-- Templates will load here -->
            </div>
        </div>
    </div>

    <!-- PDF Viewer Modal -->
    <div class="pdf-modal" id="pdf-modal">
        <div class="pdf-container">
            <div class="pdf-header">
                <h3 style="color: #8B008B;">üìÑ PDF Viewer</h3>
                <button onclick="closePDFViewer()" style="background: #FF1493; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer;">
                    Close
                </button>
            </div>
            <div class="pdf-canvas-container" id="pdf-canvas-container">
                <!-- PDF pages will be rendered here -->
            </div>
            <div class="pdf-nav" id="pdf-nav">
                <button onclick="prevPDFPage()">‚óÄ Previous</button>
                <span id="pdf-page-info">Page: 1 / 1</span>
                <button onclick="nextPDFPage()">Next ‚ñ∂</button>
                <button onclick="importPDFPageToCanvas()" style="margin-left: auto; background: #8B008B;">Import to Canvas</button>
            </div>
        </div>
    </div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/4.5.0/fabric.min.js"></script>
    <!-- PDF.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- JSZip for creating ZIP files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <script>
        // ===== PAGE NAVIGATION =====
        function launchEditor() {
            document.getElementById('landing-page').style.display = 'none';
            document.getElementById('editor-page').style.display = 'block';
            
            // Initialize editor if not already done
            if (!canvas) {
                initEditor();
            } else {
                // If canvas already exists, ensure current page is loaded
                loadPage(currentPageIndex);
                updatePagesList();
                updateStatus('üé® Welcome back to StudioBuddy!');
            }
        }
        
        function backToLanding() {
            document.getElementById('editor-page').style.display = 'none';
            document.getElementById('landing-page').style.display = 'flex';
        }
        
        // ===== EDITOR VARIABLES =====
        let canvas = null;
        let pages = [];
        let currentPageIndex = 0;
        let currentTool = 'select';
        let currentBrush = 'pencil';
        let brushColor = '#000000';
        let fillColor = '#FF1493';
        let brushSize = 3;
        let cleanWritingEnabled = true;
        let smoothingAmount = 0.7;
        
        // Grid variables
        let isGridVisible = false;
        let gridObjects = [];
        
        // Ruler variables
        let isRulerMode = false;
        let rulerPoints = [];
        let rulerLines = [];
        
        // Cutout variables
        let isCutoutMode = false;
        let cutoutPoints = [];
        let cutoutLines = [];
        let selectedImageForCutout = null;
        
        // PDF variables
        let pdfDoc = null;
        let pdfPageNum = 1;
        let pdfPageRendering = false;
        let pdfPageNumPending = null;
        let pdfScale = 1.0;
        
        // ===== EDITOR INITIALIZATION =====
        function initEditor() {
            canvas = new fabric.Canvas('main-canvas', {
                backgroundColor: '#ffffff',
                selectionColor: 'rgba(255, 20, 147, 0.3)',
                selectionLineWidth: 2,
                preserveObjectStacking: true,
                renderOnAddRemove: true
            });
            
            // Initialize UI elements
            document.getElementById('brush-color').value = brushColor;
            document.getElementById('fill-color').value = fillColor;
            document.getElementById('brush-size').value = brushSize;
            document.getElementById('clean-writing-toggle').checked = cleanWritingEnabled;
            document.getElementById('smoothing-slider').value = smoothingAmount;
            document.getElementById('smoothing-value').textContent = smoothingAmount;
            
            // Set initial tools
            setBrush('pencil');
            setTool('select');
            
            // Load saved pages or create initial page
            if (pages.length === 0) {
                pages = [{
                    id: 1,
                    name: 'Page 1',
                    canvasState: null,
                    thumbnail: null,
                    hasGrid: false,
                    backgroundColor: '#ffffff'
                }];
                currentPageIndex = 0;
            }
            
            // Load the current page
            loadPage(currentPageIndex);
            updatePagesList();
            setupKeyboardShortcuts();
            
            updateStatus('üé® StudioBuddy Ready! Upload images or start drawing');
        }
        
        // ===== FIXED STAR SHAPE =====
        function createStarPath(outerRadius, innerRadius, points) {
            const path = [];
            const angleStep = Math.PI / points;
            
            for (let i = 0; i < 2 * points; i++) {
                const angle = i * angleStep;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const x = radius * Math.sin(angle);
                const y = radius * Math.cos(angle);
                
                if (i === 0) {
                    path.push('M', x, y);
                } else {
                    path.push('L', x, y);
                }
            }
            
            path.push('Z');
            return path.join(' ');
        }
        
        // ===== HANDWRITING SMOOTHING FUNCTIONS =====
        function applySmoothingToPath(path, tension = 0.7) {
            if (!path || !path.path || path.path.length < 2) return path;
            
            // Convert fabric.js path to simple points
            const points = [];
            let currentX = 0, currentY = 0;
            
            // Extract points from fabric path
            for (let i = 0; i < path.path.length; i++) {
                const command = path.path[i];
                if (command[0] === 'L' || command[0] === 'M') {
                    currentX = command[1];
                    currentY = command[2];
                    points.push({ x: currentX, y: currentY });
                } else if (command[0] === 'Q' || command[0] === 'C') {
                    // For curves, use control points
                    for (let j = 1; j < command.length; j += 2) {
                        if (j + 1 < command.length) {
                            points.push({ x: command[j], y: command[j+1] });
                        }
                    }
                }
            }
            
            if (points.length < 3) return path;
            
            // Apply smoothing using Catmull-Rom spline
            const smoothedPoints = [];
            
            for (let i = 0; i < points.length - 1; i++) {
                const p0 = i > 0 ? points[i-1] : points[i];
                const p1 = points[i];
                const p2 = points[i+1];
                const p3 = i < points.length - 2 ? points[i+2] : points[i+1];
                
                for (let t = 0; t <= 1; t += 0.2) { // Add intermediate points
                    const t2 = t * t;
                    const t3 = t2 * t;
                    
                    const x = 0.5 * (
                        (2 * p1.x) +
                        (-p0.x + p2.x) * t +
                        (2*p0.x - 5*p1.x + 4*p2.x - p3.x) * t2 +
                        (-p0.x + 3*p1.x - 3*p2.x + p3.x) * t3
                    );
                    
                    const y = 0.5 * (
                        (2 * p1.y) +
                        (-p0.y + p2.y) * t +
                        (2*p0.y - 5*p1.y + 4*p2.y - p3.y) * t2 +
                        (-p0.y + 3*p1.y - 3*p2.y + p3.y) * t3
                    );
                    
                    smoothedPoints.push({ x, y });
                }
            }
            
            // Create new smoothed path
            if (smoothedPoints.length > 0) {
                const newPath = [];
                newPath.push(['M', smoothedPoints[0].x, smoothedPoints[0].y]);
                
                for (let i = 1; i < smoothedPoints.length; i++) {
                    newPath.push(['L', smoothedPoints[i].x, smoothedPoints[i].y]);
                }
                
                path.set({ path: newPath });
            }
            
            return path;
        }
        
        function simplifyPath(path, tolerance = 1) {
            if (!path || path.length < 3) return path;
            
            // Convert to points array
            const points = [];
            for (let i = 0; i < path.length; i++) {
                if (path[i][0] === 'M' || path[i][0] === 'L') {
                    points.push({
                        x: path[i][1],
                        y: path[i][2],
                        command: path[i][0]
                    });
                }
            }
            
            if (points.length < 3) return path;
            
            // Douglas-Peucker simplification
            const simplified = [points[0]];
            
            function douglasPeucker(points, start, end, tolerance) {
                let maxDistance = 0;
                let index = 0;
                
                const startPoint = points[start];
                const endPoint = points[end];
                
                for (let i = start + 1; i < end; i++) {
                    const distance = perpendicularDistance(
                        points[i],
                        startPoint,
                        endPoint
                    );
                    
                    if (distance > maxDistance) {
                        index = i;
                        maxDistance = distance;
                    }
                }
                
                if (maxDistance > tolerance) {
                    douglasPeucker(points, start, index, tolerance);
                    simplified.push(points[index]);
                    douglasPeucker(points, index, end, tolerance);
                }
            }
            
            douglasPeucker(points, 0, points.length - 1, tolerance);
            simplified.push(points[points.length - 1]);
            
            // Convert back to fabric.js path format
            const newPath = [];
            for (let i = 0; i < simplified.length; i++) {
                const command = i === 0 ? 'M' : 'L';
                newPath.push([command, simplified[i].x, simplified[i].y]);
            }
            
            return newPath;
        }
        
        function perpendicularDistance(point, lineStart, lineEnd) {
            const area = Math.abs(
                (lineEnd.x - lineStart.x) * (lineStart.y - point.y) -
                (lineStart.x - point.x) * (lineEnd.y - lineStart.y)
            );
            
            const lineLength = Math.sqrt(
                Math.pow(lineEnd.x - lineStart.x, 2) + 
                Math.pow(lineEnd.y - lineStart.y, 2)
            );
            
            return lineLength > 0 ? area / lineLength : 0;
        }
        
        function initSmoothDrawing() {
            if (!canvas) return;
            
            // Save the original render function
            const originalRender = canvas.freeDrawingBrush._render;
            
            // Override the render function to apply smoothing
            canvas.freeDrawingBrush._render = function() {
                originalRender.call(this);
                
                if (cleanWritingEnabled && this._points && this._points.length > 5) {
                    // Get the last drawn path
                    const objects = canvas.getObjects();
                    const lastPath = objects[objects.length - 1];
                    
                    if (lastPath && lastPath.type === 'path') {
                        // Apply smoothing with current smoothing amount
                        applySmoothingToPath(lastPath, smoothingAmount);
                        
                        // Simplify the path for cleaner look
                        lastPath.path = simplifyPath(lastPath.path, 1.0);
                        
                        canvas.renderAll();
                    }
                }
            };
        }
        
        function smoothAllDrawings() {
            const objects = canvas.getObjects();
            let smoothedCount = 0;
            
            objects.forEach(obj => {
                if (obj.type === 'path') {
                    applySmoothingToPath(obj, smoothingAmount);
                    obj.path = simplifyPath(obj.path, 1.5);
                    smoothedCount++;
                }
            });
            
            canvas.renderAll();
            updateStatus(`‚ú® Smoothed ${smoothedCount} drawing${smoothedCount !== 1 ? 's' : ''}`);
        }
        
        function changeSmoothing(value) {
            smoothingAmount = parseFloat(value);
            document.getElementById('smoothing-value').textContent = value.toFixed(1);
            updateStatus(`Smoothing set to: ${value}`);
        }
        
        // ===== FIXED SHAPES =====
        function addShape(shapeType) {
            let shape;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            switch(shapeType) {
                case 'rectangle':
                    shape = new fabric.Rect({
                        left: centerX - 50,
                        top: centerY - 50,
                        width: 100,
                        height: 100,
                        fill: fillColor + '80',
                        stroke: brushColor,
                        strokeWidth: 2,
                        selectable: true
                    });
                    break;
                case 'circle':
                    shape = new fabric.Circle({
                        left: centerX - 50,
                        top: centerY - 50,
                        radius: 50,
                        fill: fillColor + '80',
                        stroke: brushColor,
                        strokeWidth: 2,
                        selectable: true
                    });
                    break;
                case 'triangle':
                    shape = new fabric.Triangle({
                        left: centerX - 50,
                        top: centerY - 50,
                        width: 100,
                        height: 100,
                        fill: fillColor + '80',
                        stroke: brushColor,
                        strokeWidth: 2,
                        selectable: true
                    });
                    break;
                case 'line':
                    shape = new fabric.Line([centerX - 50, centerY, centerX + 50, centerY], {
                        stroke: brushColor,
                        strokeWidth: 3,
                        selectable: true
                    });
                    break;
                case 'arrow':
                    shape = new fabric.Line([centerX - 50, centerY, centerX + 50, centerY], {
                        stroke: brushColor,
                        strokeWidth: 3,
                        selectable: true
                    });
                    // Add arrowhead
                    const arrow = new fabric.Triangle({
                        left: centerX + 35,
                        top: centerY - 10,
                        width: 20,
                        height: 20,
                        fill: brushColor,
                        angle: 0,
                        selectable: false,
                        evented: false
                    });
                    canvas.add(shape, arrow);
                    updateStatus(`‚úÖ Added ${shapeType}`);
                    return;
                case 'star':
                    // Fixed star shape using Path
                    const starPath = createStarPath(50, 20, 5);
                    shape = new fabric.Path(starPath, {
                        left: centerX,
                        top: centerY,
                        fill: fillColor + '80',
                        stroke: brushColor,
                        strokeWidth: 2,
                        selectable: true,
                        originX: 'center',
                        originY: 'center'
                    });
                    break;
                case 'heart':
                    // Heart shape
                    const heartPath = 'M 0,10 C 0,10 0,0 10,0 C 20,0 20,10 30,10 C 40,10 40,0 50,0 C 60,0 60,10 60,10 L 60,30 L 30,50 L 0,30 Z';
                    shape = new fabric.Path(heartPath, {
                        left: centerX - 30,
                        top: centerY - 25,
                        scaleX: 0.4,
                        scaleY: 0.4,
                        fill: fillColor + '80',
                        stroke: brushColor,
                        strokeWidth: 2,
                        selectable: true
                    });
                    break;
                case 'hexagon':
                    // Hexagon shape
                    const hexagonPath = 'M 0,-50 L 43,-25 L 43,25 L 0,50 L -43,25 L -43,-25 Z';
                    shape = new fabric.Path(hexagonPath, {
                        left: centerX,
                        top: centerY,
                        fill: fillColor + '80',
                        stroke: brushColor,
                        strokeWidth: 2,
                        selectable: true,
                        originX: 'center',
                        originY: 'center'
                    });
                    break;
                case 'oval':
                    shape = new fabric.Ellipse({
                        left: centerX - 60,
                        top: centerY - 40,
                        rx: 60,
                        ry: 40,
                        fill: fillColor + '80',
                        stroke: brushColor,
                        strokeWidth: 2,
                        selectable: true
                    });
                    break;
            }
            
            if (shape) {
                canvas.add(shape);
                canvas.setActiveObject(shape);
                canvas.renderAll();
                updateStatus(`‚úÖ Added ${shapeType}`);
            }
        }
        
        // ===== TEMPLATE SYSTEM =====
        const templates = {
            noteTemplates: [
                {
                    id: 'cornell-notes',
                    name: 'Cornell Notes',
                    icon: 'üìì',
                    description: 'Classic note-taking system',
                    create: function() {
                        clearCanvas();
                        // Add Cornell Notes layout
                        addGrid();
                        
                        // Title area
                        const title = new fabric.Text('Subject: ', {
                            left: 50,
                            top: 30,
                            fontSize: 24,
                            fill: '#8B008B',
                            fontFamily: 'Arial'
                        });
                        
                        // Main notes area
                        const notesRect = new fabric.Rect({
                            left: 300,
                            top: 100,
                            width: 400,
                            height: 400,
                            fill: 'transparent',
                            stroke: '#FF1493',
                            strokeWidth: 2,
                            strokeDashArray: [5, 5]
                        });
                        
                        // Cue column
                        const cueRect = new fabric.Rect({
                            left: 50,
                            top: 100,
                            width: 200,
                            height: 400,
                            fill: 'transparent',
                            stroke: '#8B008B',
                            strokeWidth: 1
                        });
                        
                        // Summary area
                        const summaryRect = new fabric.Rect({
                            left: 50,
                            top: 520,
                            width: 650,
                            height: 50,
                            fill: 'transparent',
                            stroke: '#FF1493',
                            strokeWidth: 1
                        });
                        
                        canvas.add(title, notesRect, cueRect, summaryRect);
                        canvas.renderAll();
                        updateStatus('üìì Cornell Notes template loaded!');
                        closeTemplatesModal();
                    }
                },
                {
                    id: 'lecture-outline',
                    name: 'Lecture Outline',
                    icon: 'üìù',
                    description: 'Structured lecture notes',
                    create: function() {
                        clearCanvas();
                        addGrid();
                        
                        const title = new fabric.Text('Lecture Outline: ', {
                            left: 50,
                            top: 30,
                            fontSize: 24,
                            fill: '#8B008B'
                        });
                        
                        // Create outline structure
                        const headings = ['I. Main Topic', 'II. Key Points', 'III. Examples', 'IV. Summary'];
                        headings.forEach((text, index) => {
                            const heading = new fabric.Text(text, {
                                left: 50,
                                top: 100 + (index * 50),
                                fontSize: 18,
                                fill: '#FF1493',
                                fontFamily: 'Arial'
                            });
                            canvas.add(heading);
                        });
                        
                        canvas.renderAll();
                        updateStatus('üìù Lecture Outline template loaded!');
                        closeTemplatesModal();
                    }
                },
                {
                    id: 'mind-map',
                    name: 'Mind Map',
                    icon: 'üß†',
                    description: 'Brainstorming diagram',
                    create: function() {
                        clearCanvas();
                        
                        const center = new fabric.Circle({
                            left: canvas.width / 2 - 50,
                            top: canvas.height / 2 - 50,
                            radius: 50,
                            fill: '#FF1493',
                            opacity: 0.7
                        });
                        
                        const centerText = new fabric.Text('Main Topic', {
                            left: canvas.width / 2 - 30,
                            top: canvas.height / 2 - 10,
                            fontSize: 16,
                            fill: 'white',
                            fontFamily: 'Arial'
                        });
                        
                        canvas.add(center, centerText);
                        
                        // Add some branches
                        const branches = [
                            {text: 'Idea 1', angle: 45},
                            {text: 'Idea 2', angle: 135},
                            {text: 'Idea 3', angle: 225},
                            {text: 'Idea 4', angle: 315}
                        ];
                        
                        branches.forEach(branch => {
                            const x = canvas.width / 2 + 70 * Math.cos(branch.angle * Math.PI / 180);
                            const y = canvas.height / 2 + 70 * Math.sin(branch.angle * Math.PI / 180);
                            
                            const branchCircle = new fabric.Circle({
                                left: x - 30,
                                top: y - 30,
                                radius: 30,
                                fill: '#8B008B',
                                opacity: 0.5
                            });
                            
                            const branchText = new fabric.Text(branch.text, {
                                left: x - 20,
                                top: y - 10,
                                fontSize: 14,
                                fill: 'white'
                            });
                            
                            // Connect line
                            const line = new fabric.Line([
                                canvas.width / 2, canvas.height / 2,
                                x, y
                            ], {
                                stroke: '#FF1493',
                                strokeWidth: 2,
                                strokeDashArray: [5, 5]
                            });
                            
                            canvas.add(line, branchCircle, branchText);
                        });
                        
                        canvas.renderAll();
                        updateStatus('üß† Mind Map template loaded!');
                        closeTemplatesModal();
                    }
                }
            ],
            
            fashionTemplates: [
                {
                    id: 'fashion-croquis',
                    name: 'Fashion Croquis',
                    icon: 'üëó',
                    description: 'Basic fashion figure template',
                    create: function() {
                        clearCanvas();
                        
                        // Create a simple fashion croquis
                        // Head
                        const head = new fabric.Circle({
                            left: canvas.width / 2 - 20,
                            top: 50,
                            radius: 20,
                            fill: '#f0f0f0',
                            stroke: '#333',
                            strokeWidth: 1
                        });
                        
                        // Body
                        const body = new fabric.Rect({
                            left: canvas.width / 2 - 15,
                            top: 90,
                            width: 30,
                            height: 100,
                            fill: '#f0f0f0',
                            stroke: '#333',
                            strokeWidth: 1
                        });
                        
                        // Legs
                        const leftLeg = new fabric.Rect({
                            left: canvas.width / 2 - 20,
                            top: 190,
                            width: 10,
                            height: 80,
                            fill: '#f0f0f0',
                            stroke: '#333',
                            strokeWidth: 1
                        });
                        
                        const rightLeg = new fabric.Rect({
                            left: canvas.width / 2 + 10,
                            top: 190,
                            width: 10,
                            height: 80,
                            fill: '#f0f0f0',
                            stroke: '#333',
                            strokeWidth: 1
                        });
                        
                        // Arms
                        const leftArm = new fabric.Rect({
                            left: canvas.width / 2 - 25,
                            top: 100,
                            width: 10,
                            height: 60,
                            fill: '#f0f0f0',
                            stroke: '#333',
                            strokeWidth: 1
                        });
                        
                        const rightArm = new fabric.Rect({
                            left: canvas.width / 2 + 15,
                            top: 100,
                            width: 10,
                            height: 60,
                            fill: '#f0f0f0',
                            stroke: '#333',
                            strokeWidth: 1
                        });
                        
                        canvas.add(head, body, leftLeg, rightLeg, leftArm, rightArm);
                        canvas.renderAll();
                        updateStatus('üëó Fashion Croquis template loaded!');
                        closeTemplatesModal();
                    }
                },
                {
                    id: 'mood-board',
                    name: 'Mood Board',
                    icon: 'üé®',
                    description: 'Creative inspiration board',
                    create: function() {
                        clearCanvas();
                        
                        // Create mood board layout
                        const title = new fabric.Text('Mood Board', {
                            left: 50,
                            top: 30,
                            fontSize: 28,
                            fill: '#8B008B',
                            fontFamily: 'Arial'
                        });
                        
                        // Create inspiration sections
                        const sections = [
                            {text: 'Colors', left: 50, top: 100},
                            {text: 'Fabrics', left: 300, top: 100},
                            {text: 'Inspiration', left: 550, top: 100}
                        ];
                        
                        sections.forEach(section => {
                            const rect = new fabric.Rect({
                                left: section.left,
                                top: section.top,
                                width: 200,
                                height: 200,
                                fill: 'transparent',
                                stroke: '#FF1493',
                                strokeWidth: 2,
                                strokeDashArray: [5, 5]
                            });
                            
                            const text = new fabric.Text(section.text, {
                                left: section.left + 10,
                                top: section.top + 10,
                                fontSize: 18,
                                fill: '#8B008B'
                            });
                            
                            canvas.add(rect, text);
                        });
                        
                        canvas.renderAll();
                        updateStatus('üé® Mood Board template loaded!');
                        closeTemplatesModal();
                    }
                }
            ],
            
            plannerTemplates: [
                {
                    id: 'weekly-planner',
                    name: 'Weekly Planner',
                    icon: 'üìÖ',
                    description: 'Weekly schedule planner',
                    create: function() {
                        clearCanvas();
                        addGrid();
                        
                        const title = new fabric.Text('Weekly Planner', {
                            left: 50,
                            top: 30,
                            fontSize: 28,
                            fill: '#8B008B',
                            fontFamily: 'Arial'
                        });
                        
                        // Days of the week
                        const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                        const dayWidth = 100;
                        
                        days.forEach((day, index) => {
                            const dayRect = new fabric.Rect({
                                left: 50 + (index * dayWidth),
                                top: 100,
                                width: dayWidth - 5,
                                height: 450,
                                fill: 'transparent',
                                stroke: '#FF1493',
                                strokeWidth: 1
                            });
                            
                            const dayText = new fabric.Text(day, {
                                left: 50 + (index * dayWidth) + 10,
                                top: 110,
                                fontSize: 14,
                                fill: '#8B008B',
                                fontFamily: 'Arial'
                            });
                            
                            // Time slots
                            for (let hour = 0; hour < 12; hour++) {
                                const timeLine = new fabric.Line([
                                    50 + (index * dayWidth), 150 + (hour * 30),
                                    50 + (index * dayWidth) + dayWidth - 5, 150 + (hour * 30)
                                ], {
                                    stroke: '#FFB6C1',
                                    strokeWidth: 0.5,
                                    selectable: false,
                                    evented: false
                                });
                                canvas.add(timeLine);
                            }
                            
                            canvas.add(dayRect, dayText);
                        });
                        
                        canvas.renderAll();
                        updateStatus('üìÖ Weekly Planner template loaded!');
                        closeTemplatesModal();
                    }
                },
                {
                    id: 'to-do-list',
                    name: 'To-Do List',
                    icon: '‚úÖ',
                    description: 'Simple task organizer',
                    create: function() {
                        clearCanvas();
                        
                        const title = new fabric.Text('To-Do List', {
                            left: 50,
                            top: 30,
                            fontSize: 28,
                            fill: '#8B008B',
                            fontFamily: 'Arial'
                        });
                        
                        // Create checkboxes
                        for (let i = 0; i < 10; i++) {
                            const checkbox = new fabric.Rect({
                                left: 50,
                                top: 100 + (i * 40),
                                width: 20,
                                height: 20,
                                fill: 'white',
                                stroke: '#FF1493',
                                strokeWidth: 2
                            });
                            
                            const taskLine = new fabric.Line([
                                80, 110 + (i * 40),
                                600, 110 + (i * 40)
                            ], {
                                stroke: '#8B008B',
                                strokeWidth: 2,
                                strokeDashArray: [5, 5]
                            });
                            
                            canvas.add(checkbox, taskLine);
                        }
                        
                        // Priority sections
                        const priorities = [
                            {text: 'High Priority', color: '#FF1493', top: 500},
                            {text: 'Medium Priority', color: '#8B008B', top: 550},
                            {text: 'Low Priority', color: '#FFB6C1', top: 600}
                        ];
                        
                        priorities.forEach(priority => {
                            const rect = new fabric.Rect({
                                left: 50,
                                top: priority.top,
                                width: 200,
                                height: 30,
                                fill: priority.color + '30',
                                stroke: priority.color,
                                strokeWidth: 2
                            });
                            
                            const text = new fabric.Text(priority.text, {
                                left: 60,
                                top: priority.top + 5,
                                fontSize: 14,
                                fill: priority.color,
                                fontFamily: 'Arial'
                            });
                            
                            canvas.add(rect, text);
                        });
                        
                        canvas.renderAll();
                        updateStatus('‚úÖ To-Do List template loaded!');
                        closeTemplatesModal();
                    }
                }
            ]
        };
        
        function loadTemplates() {
            const modal = document.getElementById('templates-modal');
            const templatesGrid = document.getElementById('templates-grid');
            
            // Clear previous templates
            templatesGrid.innerHTML = '';
            
            // Add all templates
            Object.keys(templates).forEach(category => {
                templates[category].forEach(template => {
                    const templateCard = document.createElement('div');
                    templateCard.className = 'template-card';
                    templateCard.onclick = template.create;
                    
                    templateCard.innerHTML = `
                        <div class="template-icon">${template.icon}</div>
                        <div class="template-name">${template.name}</div>
                        <div class="template-desc">${template.description}</div>
                    `;
                    
                    templatesGrid.appendChild(templateCard);
                });
            });
            
            modal.style.display = 'flex';
        }
        
        function closeTemplatesModal() {
            document.getElementById('templates-modal').style.display = 'none';
        }
        
        // ===== PDF UPLOAD FUNCTION =====
        function uploadPDF() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.pdf';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                if (file.type !== 'application/pdf') {
                    updateStatus('‚ùå Please select a PDF file');
                    return;
                }
                
                updateStatus('üìÑ Loading PDF...');
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    const typedarray = new Uint8Array(event.target.result);
                    
                    // Load PDF using PDF.js
                    pdfjsLib.getDocument(typedarray).promise.then(function(pdf) {
                        pdfDoc = pdf;
                        pdfPageNum = 1;
                        
                        // Show PDF viewer modal
                        document.getElementById('pdf-modal').style.display = 'flex';
                        
                        // Render first page
                        renderPDFPage(pdfPageNum);
                        
                        updateStatus('‚úÖ PDF loaded successfully');
                    }).catch(function(error) {
                        console.error('PDF loading error:', error);
                        updateStatus('‚ùå Error loading PDF');
                    });
                };
                
                reader.readAsArrayBuffer(file);
            };
            input.click();
        }
        
        function renderPDFPage(num) {
            if (!pdfDoc) return;
            
            pdfPageRendering = true;
            
            pdfDoc.getPage(num).then(function(page) {
                const container = document.getElementById('pdf-canvas-container');
                container.innerHTML = '';
                
                const viewport = page.getViewport({ scale: pdfScale });
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                
                container.appendChild(canvas);
                
                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };
                
                page.render(renderContext).promise.then(function() {
                    pdfPageRendering = false;
                    if (pdfPageNumPending !== null) {
                        renderPDFPage(pdfPageNumPending);
                        pdfPageNumPending = null;
                    }
                    
                    // Update page info
                    document.getElementById('pdf-page-info').textContent = 
                        `Page: ${num} / ${pdfDoc.numPages}`;
                });
            });
        }
        
        function queueRenderPDFPage(num) {
            if (pdfPageRendering) {
                pdfPageNumPending = num;
            } else {
                renderPDFPage(num);
            }
        }
        
        function prevPDFPage() {
            if (pdfPageNum <= 1) return;
            pdfPageNum--;
            queueRenderPDFPage(pdfPageNum);
        }
        
        function nextPDFPage() {
            if (pdfPageNum >= pdfDoc.numPages) return;
            pdfPageNum++;
            queueRenderPDFPage(pdfPageNum);
        }
        
        function closePDFViewer() {
            document.getElementById('pdf-modal').style.display = 'none';
            pdfDoc = null;
        }
        
        function importPDFPageToCanvas() {
            if (!pdfDoc) return;
            
            const container = document.getElementById('pdf-canvas-container');
            const pdfCanvas = container.querySelector('canvas');
            
            if (!pdfCanvas) {
                updateStatus('‚ùå No PDF page to import');
                return;
            }
            
            // Convert PDF canvas to image
            const dataURL = pdfCanvas.toDataURL('image/png');
            
            fabric.Image.fromURL(dataURL, function(img) {
                // Scale to fit canvas
                const maxWidth = canvas.width * 0.8;
                const maxHeight = canvas.height * 0.8;
                let scale = 1;
                
                if (img.width > maxWidth || img.height > maxHeight) {
                    scale = Math.min(maxWidth / img.width, maxHeight / img.height);
                }
                
                img.set({
                    left: canvas.width / 2 - (img.width * scale) / 2,
                    top: canvas.height / 2 - (img.height * scale) / 2,
                    scaleX: scale,
                    scaleY: scale,
                    selectable: true,
                    hasControls: true
                });
                
                canvas.add(img);
                canvas.setActiveObject(img);
                canvas.renderAll();
                
                // Close PDF viewer
                closePDFViewer();
                updateStatus('‚úÖ PDF page imported to canvas');
            });
        }
        
        // ===== MULTI-PAGE DOWNLOAD FUNCTIONS =====
        function downloadAllPages() {
            // Save current page state first
            saveCurrentPageState();
            
            // Show download modal
            showDownloadModal();
        }
        
        function showDownloadModal() {
            const modal = document.getElementById('download-modal');
            const optionsContainer = document.getElementById('download-options');
            
            // Clear previous options
            optionsContainer.innerHTML = '';
            
            // Create checkboxes for each page
            pages.forEach((page, index) => {
                const pageOption = document.createElement('div');
                pageOption.className = 'page-option';
                
                pageOption.innerHTML = `
                    <input type="checkbox" id="page-${index}" checked>
                    <label for="page-${index}">
                        <strong>${page.name}</strong>
                        ${page.hasGrid ? ' üìê' : ''} 
                        ${page.canvasState ? ' üñºÔ∏è' : ' üìÑ'}
                    </label>
                `;
                
                optionsContainer.appendChild(pageOption);
            });
            
            modal.style.display = 'flex';
        }
        
        function closeDownloadModal() {
            document.getElementById('download-modal').style.display = 'none';
        }
        
        function downloadAllPagesAsZip() {
            closeDownloadModal();
            downloadSelectedPages(true);
        }
        
        function downloadSelectedPages(allPages = false) {
            closeDownloadModal();
            
            // Get selected pages
            const selectedPages = [];
            
            if (allPages) {
                // Download all pages
                pages.forEach((page, index) => {
                    selectedPages.push(index);
                });
            } else {
                // Get checked pages
                pages.forEach((page, index) => {
                    const checkbox = document.getElementById(`page-${index}`);
                    if (checkbox && checkbox.checked) {
                        selectedPages.push(index);
                    }
                });
            }
            
            if (selectedPages.length === 0) {
                updateStatus('‚ùå No pages selected');
                return;
            }
            
            if (selectedPages.length === 1) {
                // Single page - just download it
                const pageIndex = selectedPages[0];
                const originalIndex = currentPageIndex;
                
                // Save current page
                saveCurrentPageState();
                
                // Load the selected page and download it
                currentPageIndex = pageIndex;
                loadPage(pageIndex);
                
                // Download the current page
                const link = document.createElement('a');
                link.download = `studiobuddy-${pages[pageIndex].name.toLowerCase().replace(' ', '-')}-${Date.now()}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
                
                // Restore original page
                currentPageIndex = originalIndex;
                loadPage(originalIndex);
                
                updateStatus(`‚úÖ Downloaded: ${pages[pageIndex].name}`);
                return;
            }
            
            // Multiple pages - create ZIP file
            updateStatus(`üì• Downloading ${selectedPages.length} pages...`);
            
            const zip = new JSZip();
            const originalIndex = currentPageIndex;
            
            // Save current page state
            saveCurrentPageState();
            
            // Track promises for async operations
            const promises = [];
            
            selectedPages.forEach(pageIndex => {
                // Load each page and capture its image
                currentPageIndex = pageIndex;
                loadPage(pageIndex);
                
                // Create a promise to add this page to the zip
                const promise = new Promise((resolve) => {
                    // Give canvas time to render
                    setTimeout(() => {
                        const dataUrl = canvas.toDataURL('image/png').split(',')[1];
                        const pageName = pages[pageIndex].name;
                        const filename = `${pageName.toLowerCase().replace(' ', '-')}.png`;
                        
                        zip.file(filename, dataUrl, { base64: true });
                        resolve();
                    }, 100);
                });
                
                promises.push(promise);
            });
            
            // Wait for all pages to be added to zip
            Promise.all(promises).then(() => {
                // Restore original page
                currentPageIndex = originalIndex;
                loadPage(originalIndex);
                
                // Generate and download the zip file
                zip.generateAsync({ type: "blob" }).then(function(content) {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(content);
                    link.download = `studiobuddy-pages-${Date.now()}.zip`;
                    link.click();
                    
                    updateStatus(`‚úÖ Downloaded ${selectedPages.length} pages as ZIP`);
                });
            });
        }
        
        // ===== DRAWING SYSTEM =====
        function setBrush(brushType) {
            if (!canvas) return;
            
            currentBrush = brushType;
            canvas.isDrawingMode = true;
            canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
            canvas.freeDrawingBrush.color = brushColor;
            
            switch(brushType) {
                case 'pencil':
                    canvas.freeDrawingBrush.width = brushSize;
                    canvas.freeDrawingBrush.opacity = 0.9;
                    if (cleanWritingEnabled) initSmoothDrawing();
                    break;
                    
                case 'handwriting':
                    // Special settings for optimal handwriting
                    canvas.freeDrawingBrush.width = brushSize + 2;
                    canvas.freeDrawingBrush.opacity = 0.95;
                    canvas.freeDrawingBrush.color = brushColor;
                    
                    // Enable enhanced smoothing automatically for handwriting brush
                    if (cleanWritingEnabled) {
                        initSmoothDrawing();
                        // Apply velocity-based width variation for natural feel
                        let lastPoint = null;
                        let lastTime = Date.now();
                        
                        canvas.on('mouse:move', function(options) {
                            if (!cleanWritingEnabled || !canvas.isDrawingMode) return;
                            
                            const currentTime = Date.now();
                            const deltaTime = currentTime - lastTime;
                            
                            if (lastPoint && deltaTime > 0) {
                                const pointer = canvas.getPointer(options.e);
                                const distance = Math.sqrt(
                                    Math.pow(pointer.x - lastPoint.x, 2) + 
                                    Math.pow(pointer.y - lastPoint.y, 2)
                                );
                                
                                const velocity = distance / deltaTime;
                                
                                // Adjust width based on velocity (slower = thicker, faster = thinner)
                                const newWidth = Math.max(brushSize * 0.5, Math.min(brushSize * 2, brushSize / (velocity + 0.1)));
                                canvas.freeDrawingBrush.width = newWidth;
                                
                                lastPoint = pointer;
                                lastTime = currentTime;
                            }
                        });
                    }
                    break;
                    
                case 'marker':
                    canvas.freeDrawingBrush.width = brushSize * 3;
                    canvas.freeDrawingBrush.opacity = 0.7;
                    break;
                    
                case 'watercolor':
                    canvas.freeDrawingBrush.width = brushSize * 4;
                    canvas.freeDrawingBrush.opacity = 0.4;
                    break;
                    
                case 'highlighter':
                    canvas.freeDrawingBrush.width = brushSize * 8;
                    canvas.freeDrawingBrush.opacity = 0.3;
                    canvas.freeDrawingBrush.color = '#FFFF00';
                    break;
                    
                case 'calligraphy':
                    canvas.freeDrawingBrush.width = brushSize * 2;
                    canvas.freeDrawingBrush.opacity = 0.9;
                    if (cleanWritingEnabled) initSmoothDrawing();
                    break;
                    
                case 'charcoal':
                    canvas.freeDrawingBrush.width = brushSize * 2;
                    canvas.freeDrawingBrush.opacity = 0.8;
                    break;
                    
                case 'spray':
                    canvas.freeDrawingBrush.width = brushSize * 5;
                    canvas.freeDrawingBrush.opacity = 0.3;
                    break;
                    
                case 'chalk':
                    canvas.freeDrawingBrush.width = brushSize * 2;
                    canvas.freeDrawingBrush.opacity = 0.6;
                    break;
            }
            
            updateStatus(`üé® Brush set to: ${brushType} ${cleanWritingEnabled ? '(with smoothing)' : ''}`);
        }
        
        function toggleCleanWriting() {
            cleanWritingEnabled = !cleanWritingEnabled;
            updateStatus(cleanWritingEnabled ? "‚úèÔ∏è Clean writing enabled (smoothing active)" : "‚úèÔ∏è Freehand drawing");
            if (canvas && canvas.isDrawingMode) {
                setBrush(currentBrush);
            }
        }
        
        // ===== FIXED GRID SYSTEM =====
        function addGrid() {
            // Clear existing grid
            if (gridObjects.length > 0) {
                gridObjects.forEach(obj => {
                    if (obj && obj.remove) {
                        canvas.remove(obj);
                    }
                });
                gridObjects = [];
            }
            
            // If turning grid off
            if (isGridVisible) {
                isGridVisible = false;
                pages[currentPageIndex].hasGrid = false;
                updateStatus('üî≤ Grid removed');
                canvas.renderAll();
                return;
            }
            
            // Create new grid
            const gridSize = 20;
            const mainGridColor = 'rgba(200, 200, 200, 0.3)';
            const thickGridColor = 'rgba(150, 150, 150, 0.5)';
            
            // Vertical lines
            for (let x = 0; x <= canvas.width; x += gridSize) {
                const isThickLine = (x % 100 === 0);
                const line = new fabric.Line([x, 0, x, canvas.height], {
                    stroke: isThickLine ? thickGridColor : mainGridColor,
                    strokeWidth: isThickLine ? 1.5 : 0.5,
                    selectable: false,
                    evented: false,
                    hasControls: false,
                    hasBorders: false,
                    lockMovementX: true,
                    lockMovementY: true,
                    lockRotation: true,
                    lockScalingX: true,
                    lockScalingY: true
                });
                canvas.add(line);
                canvas.sendToBack(line);
                gridObjects.push(line);
            }
            
            // Horizontal lines
            for (let y = 0; y <= canvas.height; y += gridSize) {
                const isThickLine = (y % 100 === 0);
                const line = new fabric.Line([0, y, canvas.width, y], {
                    stroke: isThickLine ? thickGridColor : mainGridColor,
                    strokeWidth: isThickLine ? 1.5 : 0.5,
                    selectable: false,
                    evented: false,
                    hasControls: false,
                    hasBorders: false,
                    lockMovementX: true,
                    lockMovementY: true,
                    lockRotation: true,
                    lockScalingX: true,
                    lockScalingY: true
                });
                canvas.add(line);
                canvas.sendToBack(line);
                gridObjects.push(line);
            }
            
            isGridVisible = true;
            pages[currentPageIndex].hasGrid = true;
            updateStatus('üî≤ Grid overlay added (20px spacing, perfect for notes!)');
            
            canvas.renderAll();
        }
        
        // ===== FIXED PAGES SYSTEM =====
        function addNewPage() {
            const pageNumber = pages.length + 1;
            
            // Save current page before adding new one
            saveCurrentPageState();
            
            pages.push({
                id: pageNumber,
                name: `Page ${pageNumber}`,
                canvasState: null,
                thumbnail: null,
                hasGrid: false,
                backgroundColor: '#ffffff'
            });
            
            currentPageIndex = pages.length - 1;
            loadPage(currentPageIndex);
            updatePagesList();
            updateStatus(`üìÑ Added blank Page ${pageNumber}`);
        }
        
        function duplicateCurrentPage() {
            if (pages.length === 0) return;
            
            saveCurrentPageState();
            
            const pageNumber = pages.length + 1;
            const currentState = JSON.stringify(canvas.toJSON());
            
            pages.push({
                id: pageNumber,
                name: `Page ${pageNumber} (Copy)`,
                canvasState: currentState,
                thumbnail: null,
                hasGrid: pages[currentPageIndex].hasGrid,
                backgroundColor: canvas.backgroundColor || '#ffffff'
            });
            
            currentPageIndex = pages.length - 1;
            loadPage(currentPageIndex);
            updatePagesList();
            updateStatus(`üìã Duplicated page as Page ${pageNumber}`);
        }
        
        function deleteCurrentPage() {
            if (pages.length <= 1) {
                updateStatus("‚ùå Cannot delete the only page");
                return;
            }
            
            if (confirm(`Delete "${pages[currentPageIndex].name}"?`)) {
                pages.splice(currentPageIndex, 1);
                
                if (currentPageIndex >= pages.length) {
                    currentPageIndex = pages.length - 1;
                }
                
                loadPage(currentPageIndex);
                updatePagesList();
                updateStatus(`üóëÔ∏è Page deleted`);
            }
        }
        
        function switchPage(index) {
            if (index === currentPageIndex) return;
            
            // Save the current page state BEFORE switching
            saveCurrentPageState();
            currentPageIndex = index;
            loadPage(index);
            updatePagesList();
        }
        
        function saveCurrentPageState() {
            if (!canvas || pages.length === 0 || currentPageIndex < 0) return;
            
            // Save grid state
            pages[currentPageIndex].hasGrid = isGridVisible;
            
            // Get complete canvas state including grid and background
            const state = canvas.toJSON();
            
            // Also save the background color
            pages[currentPageIndex].backgroundColor = canvas.backgroundColor;
            
            // Save the state
            pages[currentPageIndex].canvasState = JSON.stringify(state);
            
            // Update the thumbnail
            updatePageThumbnail(currentPageIndex);
        }
        
        function loadPage(index) {
            if (!canvas || index < 0 || index >= pages.length) return;
            
            // Clear grid objects first
            if (gridObjects.length > 0) {
                gridObjects.forEach(obj => {
                    if (obj && obj.remove) {
                        canvas.remove(obj);
                    }
                });
                gridObjects = [];
            }
            
            // Clear the canvas
            canvas.clear();
            
            const page = pages[index];
            
            // Set background color
            canvas.backgroundColor = page.backgroundColor || '#ffffff';
            
            // Load saved state if it exists
            if (page.canvasState) {
                try {
                    // Temporarily disable drawing mode
                    const wasDrawingMode = canvas.isDrawingMode;
                    canvas.isDrawingMode = false;
                    
                    canvas.loadFromJSON(page.canvasState, function() {
                        // Re-enable drawing mode if it was enabled
                        if (wasDrawingMode) {
                            canvas.isDrawingMode = true;
                            setBrush(currentBrush); // Restore current brush
                        }
                        
                        // Add grid if this page has it
                        if (page.hasGrid) {
                            isGridVisible = true;
                            addGrid(); // This will actually create the grid
                        } else {
                            isGridVisible = false;
                        }
                        
                        canvas.renderAll();
                        updateStatus(`üìÑ Now viewing: ${page.name}`);
                    });
                } catch (error) {
                    console.error('Error loading page:', error);
                    updateStatus(`‚ùå Error loading page. Starting fresh.`);
                    
                    // If load fails, create empty page
                    if (page.hasGrid) {
                        isGridVisible = true;
                        addGrid();
                    } else {
                        isGridVisible = false;
                    }
                    
                    canvas.renderAll();
                }
            } else {
                // Fresh page - add grid if needed
                if (page.hasGrid) {
                    isGridVisible = true;
                    addGrid();
                } else {
                    isGridVisible = false;
                }
                
                canvas.renderAll();
                updateStatus(`üìÑ Now viewing: ${page.name}`);
            }
        }
        
        function updatePagesList() {
            const pagesList = document.getElementById('pages-list');
            pagesList.innerHTML = '';
            
            pages.forEach((page, index) => {
                const pageEl = document.createElement('div');
                pageEl.className = `page-thumbnail ${index === currentPageIndex ? 'active' : ''}`;
                pageEl.innerHTML = `
                    <div style="font-weight: bold;">${page.name}</div>
                    <div style="font-size: 10px; color: #666;">
                        ${page.hasGrid ? 'üìê' : ''} 
                        ${page.canvasState ? 'üñºÔ∏è' : 'üìÑ'}
                    </div>
                `;
                pageEl.onclick = () => switchPage(index);
                pagesList.appendChild(pageEl);
            });
        }
        
        // ===== ADD PAGE THUMBNAIL FUNCTION =====
        function updatePageThumbnail(pageIndex) {
            if (!canvas || pageIndex < 0) return;
            
            // Create a smaller version of the canvas for thumbnail
            const thumbnailCanvas = document.createElement('canvas');
            const ctx = thumbnailCanvas.getContext('2d');
            
            // Set thumbnail size
            thumbnailCanvas.width = 80;
            thumbnailCanvas.height = 60;
            
            // Scale down the main canvas
            const scale = Math.min(80 / canvas.width, 60 / canvas.height);
            
            // Draw the current canvas state to thumbnail
            const dataUrl = canvas.toDataURL('image/png');
            const img = new Image();
            img.onload = function() {
                ctx.drawImage(img, 0, 0, canvas.width * scale, canvas.height * scale);
                
                // Store thumbnail data URL
                pages[pageIndex].thumbnail = thumbnailCanvas.toDataURL('image/png');
            };
            img.src = dataUrl;
        }
        
        // ===== RULER TOOL =====
        function toggleRuler() {
            if (isRulerMode) {
                exitRulerMode();
                setTool('select');
                updateStatus('üìè Measurement tool disabled');
            } else {
                isRulerMode = true;
                rulerPoints = [];
                rulerLines = [];
                
                canvas.isDrawingMode = false;
                canvas.selection = false;
                canvas.defaultCursor = 'crosshair';
                
                canvas.off('mouse:down');
                canvas.on('mouse:down', handleRulerClick);
                
                document.getElementById('ruler-btn').classList.add('active-tool');
                updateStatus('üìè Click two points to measure distance.');
            }
        }
        
        function handleRulerClick(options) {
            if (!isRulerMode) return;
            
            const pointer = canvas.getPointer(options.e);
            
            const point = new fabric.Circle({
                left: pointer.x - 5,
                top: pointer.y - 5,
                radius: 5,
                fill: '#FF1493',
                stroke: '#8B008B',
                strokeWidth: 2,
                selectable: false,
                evented: false,
                hasControls: false,
                hasBorders: false
            });
            
            canvas.add(point);
            rulerPoints.push({x: pointer.x, y: pointer.y, obj: point});
            
            if (rulerPoints.length === 2) {
                const p1 = rulerPoints[0];
                const p2 = rulerPoints[1];
                
                const distance = Math.sqrt(
                    Math.pow(p2.x - p1.x, 2) + 
                    Math.pow(p2.y - p1.y, 2)
                );
                
                const line = new fabric.Line([p1.x, p1.y, p2.x, p2.y], {
                    stroke: '#FF1493',
                    strokeWidth: 2,
                    strokeDashArray: [5, 5],
                    selectable: false,
                    evented: false
                });
                
                canvas.add(line);
                rulerLines.push(line);
                
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                
                const text = new fabric.Text(`${Math.round(distance)}px`, {
                    left: midX,
                    top: midY - 20,
                    fontSize: 14,
                    fill: '#8B008B',
                    backgroundColor: 'rgba(255, 255, 255, 0.8)',
                    selectable: false,
                    evented: false
                });
                
                canvas.add(text);
                rulerLines.push(text);
                
                updateStatus(`üìè Measurement: ${Math.round(distance)} pixels`);
                
                setTimeout(() => {
                    rulerPoints = [];
                }, 1000);
            }
            
            canvas.renderAll();
        }
        
        function exitRulerMode() {
            isRulerMode = false;
            
            rulerPoints.forEach(point => {
                if (point.obj && point.obj.remove) {
                    canvas.remove(point.obj);
                }
            });
            
            rulerLines.forEach(line => {
                if (line && line.remove) {
                    canvas.remove(line);
                }
            });
            
            rulerPoints = [];
            rulerLines = [];
            
            canvas.off('mouse:down');
            document.getElementById('ruler-btn').classList.remove('active-tool');
        }
        
        // ===== OTHER TOOLS =====
        function clearCanvas() {
            if (confirm('Clear everything on this page?')) {
                canvas.clear();
                canvas.backgroundColor = '#ffffff';
                
                isGridVisible = false;
                gridObjects.forEach(obj => {
                    if (obj && obj.remove) {
                        canvas.remove(obj);
                    }
                });
                gridObjects = [];
                
                if (pages[currentPageIndex].hasGrid) {
                    isGridVisible = true;
                    addGrid();
                }
                
                saveCurrentPageState();
                canvas.renderAll();
                updateStatus('üóëÔ∏è Canvas cleared');
            }
        }
        
        function uploadImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    fabric.Image.fromURL(event.target.result, function(img) {
                        const maxWidth = 600;
                        const maxHeight = 400;
                        let scale = 1;
                        
                        if (img.width > maxWidth || img.height > maxHeight) {
                            scale = Math.min(maxWidth / img.width, maxHeight / img.height);
                        }
                        
                        img.set({
                            left: canvas.width / 2 - (img.width * scale) / 2,
                            top: canvas.height / 2 - (img.height * scale) / 2,
                            scaleX: scale,
                            scaleY: scale,
                            selectable: true,
                            hasControls: true
                        });
                        
                        canvas.add(img);
                        canvas.setActiveObject(img);
                        canvas.renderAll();
                        
                        updateStatus(`‚úÖ Image uploaded`);
                    });
                };
                reader.readAsDataURL(file);
            };
            input.click();
        }
        
        function addText() {
            const text = new fabric.Textbox('Double click to edit', {
                left: canvas.width / 2 - 100,
                top: canvas.height / 2 - 20,
                width: 200,
                fontSize: 20,
                fill: brushColor,
                fontFamily: 'Arial',
                selectable: true,
                editable: true
            });
            
            canvas.add(text);
            canvas.setActiveObject(text);
            canvas.renderAll();
            updateStatus('üî§ Text added');
        }
        
        function changeBrushColor(color) {
            brushColor = color;
            if (canvas && canvas.freeDrawingBrush) {
                canvas.freeDrawingBrush.color = color;
            }
        }
        
        function changeFillColor(color) {
            fillColor = color;
        }
        
        function changeBrushSize(size) {
            brushSize = parseInt(size);
            document.getElementById('brush-size-value').textContent = size;
            
            if (canvas && canvas.freeDrawingBrush) {
                canvas.freeDrawingBrush.width = brushSize;
                setBrush(currentBrush);
            }
        }
        
        function saveTemplate() {
            saveCurrentPageState();
            const data = JSON.stringify({
                pages: pages,
                currentPageIndex: currentPageIndex
            });
            localStorage.setItem('studiobuddy_template', data);
            updateStatus('üíæ Template saved to browser storage');
        }
        
        function downloadDesign() {
            const link = document.createElement('a');
            link.download = `studiobuddy-design-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            updateStatus('‚úÖ Design downloaded as PNG');
        }
        
        function updateStatus(message) {
            document.getElementById('status').innerHTML = `<strong>Status:</strong> ${message}`;
        }
        
        function setTool(tool) {
            if (!canvas) return;
            
            if (isRulerMode && tool !== 'ruler') {
                exitRulerMode();
            }
            
            if (isCutoutMode && tool !== 'cutout') {
                isCutoutMode = false;
            }
            
            currentTool = tool;
            
            ['select-btn', 'draw-btn', 'cutout-btn', 'ruler-btn'].forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.classList.remove('active-tool');
            });
            
            const activeBtn = document.getElementById(tool + '-btn');
            if (activeBtn) activeBtn.classList.add('active-tool');
            
            switch(tool) {
                case 'select':
                    canvas.isDrawingMode = false;
                    canvas.selection = true;
                    canvas.defaultCursor = 'default';
                    updateStatus('‚úã Select tool');
                    break;
                    
                case 'draw':
                    canvas.isDrawingMode = true;
                    canvas.selection = false;
                    setBrush(currentBrush);
                    canvas.defaultCursor = 'crosshair';
                    updateStatus('‚úèÔ∏è Draw tool');
                    break;
                    
                case 'cutout':
                    startCutoutMode();
                    break;
                    
                case 'ruler':
                    toggleRuler();
                    break;
            }
            
            canvas.renderAll();
        }
        
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                
                switch(e.key) {
                    case 'Escape':
                        if (isRulerMode) {
                            exitRulerMode();
                            setTool('select');
                        }
                        break;
                    case 'Delete':
                    case 'Backspace':
                        const activeObject = canvas.getActiveObject();
                        if (activeObject) {
                            canvas.remove(activeObject);
                            canvas.renderAll();
                        }
                        break;
                    case 'g':
                        if (e.ctrlKey) {
                            e.preventDefault();
                            addGrid();
                        }
                        break;
                }
            });
        }
        
        function addMannequin() {
            const body = new fabric.Rect({
                left: canvas.width / 2 - 30,
                top: canvas.height / 2 - 100,
                width: 60,
                height: 200,
                fill: '#f0f0f0',
                stroke: '#333',
                strokeWidth: 2,
                selectable: true
            });
            
            const head = new fabric.Circle({
                left: canvas.width / 2 - 25,
                top: canvas.height / 2 - 125,
                radius: 25,
                fill: '#f0f0f0',
                stroke: '#333',
                strokeWidth: 2,
                selectable: true
            });
            
            canvas.add(body, head);
            canvas.renderAll();
            updateStatus('üßç Mannequin added');
        }
        
        function addFrenchCurve() {
            const curve = new fabric.Path('M 100 200 Q 200 100 300 200', {
                left: canvas.width / 2 - 150,
                top: canvas.height / 2 - 100,
                stroke: brushColor,
                strokeWidth: 3,
                fill: 'transparent',
                selectable: true
            });
            
            canvas.add(curve);
            canvas.setActiveObject(curve);
            updateStatus('üåÄ French curve added');
        }
        
        function toggleSymmetry() {
            updateStatus('üîÑ Symmetry tool coming soon!');
        }
        
        function startCutoutMode() {
            const activeObject = canvas.getActiveObject();
            if (activeObject && activeObject.type === 'image') {
                updateStatus('‚úÇÔ∏è Cutout tool: Select area with polygon tool first');
            } else {
                updateStatus('‚ùå Please select an image first');
            }
        }
        
        function convertToSketch() {
            const activeObject = canvas.getActiveObject();
            if (!activeObject || activeObject.type !== 'image') {
                updateStatus('‚ùå Please select an image first');
                return;
            }
            
            updateStatus('üé® Converting to sketch...');
            
            const imgElement = activeObject.getElement();
            const canvasTemp = document.createElement('canvas');
            const ctx = canvasTemp.getContext('2d');
            
            canvasTemp.width = imgElement.width;
            canvasTemp.height = imgElement.height;
            
            ctx.drawImage(imgElement, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvasTemp.width, canvasTemp.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i+1] + data[i+2]) / 3;
                const sketchValue = 255 - avg;
                data[i] = sketchValue;
                data[i+1] = sketchValue;
                data[i+2] = sketchValue;
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            fabric.Image.fromURL(canvasTemp.toDataURL(), function(sketchImg) {
                sketchImg.set({
                    left: activeObject.left,
                    top: activeObject.top,
                    scaleX: activeObject.scaleX,
                    scaleY: activeObject.scaleY,
                    angle: activeObject.angle,
                    selectable: true
                });
                
                canvas.remove(activeObject);
                canvas.add(sketchImg);
                canvas.setActiveObject(sketchImg);
                canvas.renderAll();
                
                updateStatus('‚úÖ Image converted to sketch!');
            });
        }
        
        // Initialize on page load
        window.onload = function() {
            const saved = localStorage.getItem('studiobuddy_template');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    pages = data.pages || [];
                    currentPageIndex = data.currentPageIndex || 0;
                } catch (e) {
                    console.log('No saved template found');
                }
            }
        };
    </script>
</body>
</html>
